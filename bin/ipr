#!/bin/sh
#
# A handy sh script to generate statefull IPTables rules
#
# $Header: ipr                                           Exp $
# $Aythor: (c) 2011-6 tokiclover <tokiclover@gmail.com>  Exp $
# $License: MIT (or 2-clause/new/simplified BSD)         Exp $
# $Version: 2.7 2016/03/30 21:09:26                      Exp $
# $Reference:                                            Exp $
#     http://www.gentoo-wiki.info/HOWTO_Iptables_and_stateful_firewalls 
#     http://www.gentoo-wiki.info/HOWTO_Iptables_for_newbies
#

if [ -n "$ZSH_VERSION" ]; then
	emulate sh
	setopt SH_WORD_SPLIT
fi

usage() {
cat <<-EOF
 usage: ${0##*/} [-e wlan0] [-i eth0] [-4|-6] [OPTIONS]
	-b, --block='1863 ntp'       block service or port 1863,ntp
	-i, --int-iface=eth0         use eth0 internal interface
	-e, --ext-iface=wlan0        use wlan0 external interface
	-d, --dhcp=[<server_ip>]     enable dhcp, use dhcp server IP
	-4, --ipv=4                  short hand for --ipv=4
	-6, --ipv=6                  short hand for --ipv=6
	-m, --module=[<modules>]     insert kernel coma separated list of kernel modules
	    --mpd=[6600]             allow in/outbound from loop back device src for mpd
	    --jabber=['5222 5269']   enable XMPP-client/server, short hand of '-s5222,5269'
	    --nat                    enable masquarading for nat/router
	    --snat                   enable snat instead for nat/router
	-t, --torrent=[50550:50555]  enable torrent traffic on those ports
	-s, --service='pop3 pop3s'   allow in/outbound for named services or ports
	-S, --save=[ipt-rules]       save ip[6]tables rules to file, default to ipt-rules
	-I, --ipset=[IPBlock]        enable IPSet set, default to adding IPBlock
	-?, -h, --help               print this help and exit
EOF
exit $?
}

pr_info()
{
	echo -e "\e[1;34m* INFO:\e[0;35m${0##*/}\e[0m: ${@}"
}
pr_error()
{
	echo -e "\e[1;31m* ERROR:\e[0;36m${0##*/}\e[0m: ${@}" >&2
}
pr_warn()
{
	echo -e "\e[1;33m* WARN:\e[0;32m${0##*/}\e[0m: ${@}" >&2
}
die()
{
	local ret="$?"; pr_error "$@"; exit "$ret"
}

grp="$(type -p grep     || exit)"
ifc="$(type -p ifconfig || exit)"
sed="$(type -p sed      || exit)"

opt=$(getopt -o '?46I::b:i:e:d::m::S::s:ht::' -l block:,ext-iface:,jabber::,ipset:: \
	-l mpd::,torrent::,int-iface:,ipv:,dhcp::,module::,mpd,save::,service:,snat,nat:: \
	-l help -n ${0##*/} -- "$@" || usage)
eval set -- "$opt"

while [ $# > 0 ]; do
	case $1 in
		--snat) snat=true; shift;;
		-e|--ext-iface) ext=$2; shift 2;;
		-i|--int-iface) int=$2; shift 2;;
		--nat) nat="${2:-true}"; shift 2;;
		-4) ipv4=true ipv="$ipv ipv4"; shift;;
		-6) ipv6=true ipv="$ipv ipv6"; shift;;
		--mpd) mpd=${2:-6600}        ; shift 2;;
		-b|--block) block="$block $2"; shift 2;;
		-s|--services) services+=" $2"; shift 2;;
		-t|--torrent) torrent=${2:-50550:50555}; shift 2;;
		-I|--ipset) net_block="$net_block ${2:-IPBlock}"; shift 2;;
		--jabber) services="$services ${2:-5222 5269}"  ; shift 2;;
		-d|--dhcp) dhcp=true dhcp_server=${2}           ; shift 2;;
		-m|--module) kmod=y module="$module $2"         ; shift 2;;
		-S|--save) save=${2:-/var/lib/iptables/ipt-rules}; shift 2;;
		--ipv)
			for i in ${2/,/ }; do 
				ipv$i=true ipv="$ipv ipv$i"
			done; shift 2;;
		--) shift; break;;
		-?|-h|--help|*) usage;;
	esac
done

case "$LC_ALL" in
	(*.[Uu][Tt][Ff]-8) ;;
	(*)	export LC_ALL="en_US.UTF-8";;
esac

if [ -z "$ext" -a -z "$int" ]; then
	ext="$($ifc | $sed -nre '/RUNNING/s/(^[we].*):.*/\1/p')"
	[ "$ext" ] || die "no running interface found"
fi
:	${dhcp:=true}
[ -n "$ipv4" ] || [ -n "$ipv6" ] || ipv4=true

block="$block 0:1 13 98 111 137:139 161:162 445 517:518 520 1214 1999 3049 4329"
block="$block 6346 3128 8000 12345 65535 98 512:515 6112 1427 9000"
services="$services git domain ssh http http-alt https ftp ftp-data ftps ipp imap2 imap3 imaps mail"
services="$services time rsync ircd ircs hkp telnets ftp ftp-data ntp"

[ -n "$ipv4" ] && module="$module iptable_filter iptable_mangle iptable_raw
iptable_nat ipt_MASQUERADE ipt_REDIRECT ipt_REJECT"
[ -n "$ipv6" ] && module="$module ip6table_filter ip6table_mangle ip6table_raw
ip6table_nat ip6t_MASQUERADE ip6t_REDIRECT ip6t_REJECT"

for mod in nf_nat_ftp nf_nat_irc nf_conntrack_ftp nf_conntrack_irc ipt_LOG \
	$module; do
	$grp -q "$mod" /proc/modules || modprobe "$mod"
done

if [ -n "$ipv4" ]; then
	echo 1 >/proc/sys/net/ipv4/tcp_syncookies
	echo 1 >/proc/sys/net/ipv4/icmp_echo_ignore_broadcasts
	echo 1 >/proc/sys/net/ipv4/ip_dynaddr
	# Source Address Verification
	for filter in /proc/sys/net/ipv4/conf/*/rp_filter; do 
		echo 1 >$filter
	done
	echo 1 >/proc/sys/net/ipv4/ip_forward
fi

for v in $ipv; do
	# Disable IP source routing and ICMP redirects
	for filter in /proc/sys/net/$v/conf/*/accept_source_route; do 
		echo 0 >$filter
	done
	for filter in /proc/sys/net/$v/conf/*/accept_redirects; do 
		echo 0 >$filter
	done
done

dorules()
{
	local net port srv
	# Deny then accept: this keeps holes from opening up while we close ports and such
	$ipt -P INPUT      DROP
	$ipt -P OUTPUT     DROP
	$ipt -P FORWARD    DROP
	# Create a few custom chains that will log dropped/rejected packets
	$ipt -N drop
	$ipt -A drop   -j LOG --log-prefix 'IPT-drop: '
	$ipt -A drop   -j DROP
	$ipt -N reject
	$ipt -A reject -j LOG --log-prefix 'IPT-reject: '
	$ipt -A reject -j REJECT
	# Log and drop bad tcp packets stated NEW without a SYN packet after being called by badtcp filter
	$ipt -N badtcp
	$ipt -A badtcp -j LOG --log-prefix 'IPT-badTCP: '
	$ipt -A badtcp -j DROP
	# Drop or rejetc bad tcp packets stated NEW but without a SYN packet
	$ipt -A badtcp  -p tcp -m conntrack --ctstate INVALID -j badtcp
	$ipt -A badtcp  -p tcp --tcp-flags SYN,ACK SYN,ACK -m conntrack --ctstate NEW -j REJECT --reject-with tcp-reset
	$ipt -A badtcp  -p tcp ! --syn -m conntrack --ctstate NEW -j badtcp
	# Add IPSet sets while at it if enabled
	for net in $net_block; do
		$ipt -I INPUT -m set --match-set "$net" src,dst -j drop
	done

	pr_info "Blocking trafic to TCP/UDP port: "
	for port in $block; do
		echo -n "$port,"
		for type in tcp udp; do
			$ipt -A INPUT   -p "$type" --dport "$port"  -j drop
			$ipt -A OUTPUT  -p "$type" --dport "$port"  -j drop
			$ipt -A FORWARD -p "$type" --dport "$port"  -j drop
		done
	done
	echo ""
	
	if [ -n "$dhcp" ]; then
		if [ -n "$ipv4" ]; then
			port="--sport 67:68 --dport 67:68"
		elif [ "$ipv6" ]; then
			port="--sport 546:547 --dport 546:547"
		fi
		$ipt -A INPUT  -p udp -i $ext $port ${dhcp_server:+-s $dhcp_server} -j ACCEPT
		$ipt -A OUTPUT -p udp -o $ext $port ${dhcp_server:+-s $dhcp_server} -j ACCEPT
	fi
	
	pr_info "Allowing inside systems to use service: "
	for port in $services; do
		echo -n "$port,"
		$ipt -A OUTPUT  -o $ext  -p tcp --dport $port --syn -m conntrack --ctstate NEW -j ACCEPT
		$ipt -A OUTPUT  -o $ext  -p udp --dport $port       -m conntrack --ctstate NEW -j ACCEPT
	done
	echo ""
	
	if [ -n "$mpd" ]; then
		pr_info "Opening TCP Output over $lbdinet:$mpd for MPD"
		$ipt -A INPUT  -p tcp --dport $mpd -s $lbdinet --syn -m conntrack --ctstate NEW -j ACCEPT
		$ipt -A OUTPUT -p tcp --dport $mpd -s $lbdinet --syn -m conntrack --ctstate NEW -j ACCEPT

	fi
	
	if [ -n "$torrent" ]; then
		# turning off DHT tracking for torrent
		pr_info "Disabling tracking on ${torrent#*:}-udp-port PREROUTING and OUTPUT"
		$ipt -t raw -A PREROUTING -i $ext -p udp --dport ${torrent#*:} -j NOTRACK
		$ipt -t raw -A OUTPUT     -o $ext -p udp --sport ${torrent#*:} -j NOTRACK
		# Torrents ports
		pr_info "Opening $torrent port for torrent"
		$ipt -A INPUT -p tcp --dport $torrent -i $ext --syn -m conntrack --ctstate NEW -j ACCEPT
		$ipt -A INPUT -p udp --dport $torrent -i $ext       -m conntrack --ctstate NEW -j ACCEPT
		$ipt -A OUTPUT -p tcp -o $ext -j ACCEPT
		$ipt -A OUTPUT -p udp -o $ext -j ACCEPT
	fi

	$ipt -A INPUT   -p tcp --dport auth --syn -m conntrack --ctstate NEW -j ACCEPT
	$ipt -A OUTPUT  -p tcp --dport auth --syn -m conntrack --ctstate NEW -j ACCEPT
	$ipt -A INPUT   -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
	$ipt -A OUTPUT  -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
	$ipt -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT

	# Allow MSQUARADING for NAT/DSL-Router
	if [ -n "$nat"  ]; then
		$ipt -t nat -A POSTROUTING -o $ext -j MASQUERADE
		case "$nat" in
			(int*) [ -n "$int" ] &&
				$ipt -t nat -A POSTROUTING -o $ext -s $int -j MASQUERADE
				;;
		esac
		# NAT I/O
		if [ -n "$ipv4" ]; then
			$ipt -A PREROUTING  -t nat -j ACCEPT
			$ipt -A POSTROUTING -t nat -j ACCEPT
			$ipt -A OUTPUT      -t nat -j ACCEPT
		fi
	fi
	# Accept trafic from/out loop back device
	$ipt -A INPUT -i $lbdiface -s $lbdinet -j ACCEPT
	$ipt -A INPUT -i $lbdiface -s $inet    -j ACCEPT
	# Allow NAT for bridged NAT/DSL-Router
	[ -n "$snat" ] && $ipt -t nat -A POSTROUTING -o $ext -j SNAT --to $inet
	# Block WAN access to internal network
	$ipt -A INPUT   -i $ext ! -d $inet -j drop
	# Block outbound ICMP (except for PING)
	$ipt -A OUTPUT  -o $ext -p $icmp ! --$icmp-type 8 -j drop
	$ipt -A FORWARD -o $ext -p $icmp ! --$icmp-type 8 -j drop
	# Allow to ping out
	$ipt -A OUTPUT  -o $ext  -p $icmp  --$icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT

	if [ -n "$ipv4" ]; then
		# Accept trafic from internal interface
		if [ -n "$int" ]; then
			$ipt -A INPUT    -i $int -s $netmask -j ACCEPT
			$ipt -A FORWARD  -o $int -s $netmask -j ACCEPT
			$ipt -A OUTPUT   -o $int -s $netmask -j ACCEPT
		fi
		# Blocking Broadcasts
		$ipt -A INPUT   -i $ext -d   $netmask -j drop
		$ipt -A OUTPUT  -o $ext -d   $netmask -j drop
		$ipt -A FORWARD -o $ext -d   $netmask -j drop
		# An additional Egress check
		$ipt -A OUTPUT  ! -o $ext -s $netmask -j drop
	fi
	# Block and log what me may have forgot
	$ipt -A INPUT   -j drop
	$ipt -A OUTPUT  -j reject
	$ipt -A FORWARD -j drop
}

doiface()
{
	local broadcast icmp iface=$1 lbdiface=lo lbdnetmask netmask net inet icmp ipt

	if [ -n "$ipv4" ]; then
		icmp=icmp ipt="$(which iptables) --modprobe=$(which modprobe)"

		for interface in "$ext:" "$lbdiface:lbd"; do
			eval set -- $($ifc ${interface%:*} | $sed -nre '/inet /p')
			while [ $# -gt 0 ]; do
				eval "${interface#*:}${1}=${2}"
				shift 2
			done
		done
		pr_info "lbdinet=$lbdinet ldbnetmask=$lbdnetmask"
		pr_info "inet=$inet broadcast=$broadcast netmask=$netmask"

		$ipt -F; $ipt -X
		if [ -n "$netmask" ]; then
			dorules
			[ -n "$save" ] && $ipt-save >$save
		else
			pr_warn "No netmask found, nothing to be done; try adding -6 (IPv6)"
		fi
	elif [ -n "$ipv6" ]; then
		icmp=icmpv6 ipt="$(which ip6tables) --modprobe=$(which modprobe)"

		for interface in "$ext:" "$lbdiface:lbd"; do
			args="$($ifc ${interface%:*} | $sed -nre '/inet6 /p')"
			eval set -- ${args%scopeid*}
			while [ $# -gt 0 ]; do
				eval "${interface#*:}${1%6}=${2}"
				shift 2
			done
		done
		pr_info "inet=$inet lbdinet=$lbdinet"

		$ipt -F; $ipt -X
		if [ -n "$inet" ]; then
			dorules
			[ -n "$save" ] && $ipt-save >${save/ipt/ip6t}
		else
			pr_warn "No netmask found, nothing to be done; try removing -6 (IPv6)"
		fi
	fi
}

if [ -n "$ext" ]; then
	doiface "$ext"
elif [ -n "$int" ]; then
	ext=$int int= && doiface "$ext"
else 
	usage
fi

#
# vim:fenc=utf-8:ci:pi:sts=0:sw=4:ts=4:
#
